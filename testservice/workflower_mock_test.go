// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package testservice

import (
	"context"
	"go.temporal.io/api/enums/v1"
	"go.temporal.io/api/workflowservice/v1"
	"go.temporal.io/sdk/client"
	"sync"
)

// Ensure, that WorkflowerMock does implement Workflower.
// If this is not the case, regenerate this file with moq.
var _ Workflower = &WorkflowerMock{}

// WorkflowerMock is a mock implementation of Workflower.
//
//	func TestSomethingThatUsesWorkflower(t *testing.T) {
//
//		// make and configure a mocked Workflower
//		mockedWorkflower := &WorkflowerMock{
//			CancelWorkflowFunc: func(ctx context.Context, workflowID string, runID string) error {
//				panic("mock out the CancelWorkflow method")
//			},
//			DescribeTaskQueueFunc: func(ctx context.Context, taskQueue string, taskQueueType enums.TaskQueueType) (*workflowservice.DescribeTaskQueueResponse, error) {
//				panic("mock out the DescribeTaskQueue method")
//			},
//			ExecuteWorkflowFunc: func(ctx context.Context, options client.StartWorkflowOptions, workflow interface{}, args ...interface{}) (client.WorkflowRun, error) {
//				panic("mock out the ExecuteWorkflow method")
//			},
//			GetWorkflowFunc: func(ctx context.Context, workflowID string, runID string) client.WorkflowRun {
//				panic("mock out the GetWorkflow method")
//			},
//			GetWorkflowHistoryFunc: func(ctx context.Context, workflowID string, runID string, isLongPoll bool, filterType enums.HistoryEventFilterType) client.HistoryEventIterator {
//				panic("mock out the GetWorkflowHistory method")
//			},
//			ResetWorkflowExecutionFunc: func(ctx context.Context, request *workflowservice.ResetWorkflowExecutionRequest) (*workflowservice.ResetWorkflowExecutionResponse, error) {
//				panic("mock out the ResetWorkflowExecution method")
//			},
//		}
//
//		// use mockedWorkflower in code that requires Workflower
//		// and then make assertions.
//
//	}
type WorkflowerMock struct {
	// CancelWorkflowFunc mocks the CancelWorkflow method.
	CancelWorkflowFunc func(ctx context.Context, workflowID string, runID string) error

	// DescribeTaskQueueFunc mocks the DescribeTaskQueue method.
	DescribeTaskQueueFunc func(ctx context.Context, taskQueue string, taskQueueType enums.TaskQueueType) (*workflowservice.DescribeTaskQueueResponse, error)

	// ExecuteWorkflowFunc mocks the ExecuteWorkflow method.
	ExecuteWorkflowFunc func(ctx context.Context, options client.StartWorkflowOptions, workflow interface{}, args ...interface{}) (client.WorkflowRun, error)

	// GetWorkflowFunc mocks the GetWorkflow method.
	GetWorkflowFunc func(ctx context.Context, workflowID string, runID string) client.WorkflowRun

	// GetWorkflowHistoryFunc mocks the GetWorkflowHistory method.
	GetWorkflowHistoryFunc func(ctx context.Context, workflowID string, runID string, isLongPoll bool, filterType enums.HistoryEventFilterType) client.HistoryEventIterator

	// ResetWorkflowExecutionFunc mocks the ResetWorkflowExecution method.
	ResetWorkflowExecutionFunc func(ctx context.Context, request *workflowservice.ResetWorkflowExecutionRequest) (*workflowservice.ResetWorkflowExecutionResponse, error)

	// calls tracks calls to the methods.
	calls struct {
		// CancelWorkflow holds details about calls to the CancelWorkflow method.
		CancelWorkflow []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkflowID is the workflowID argument value.
			WorkflowID string
			// RunID is the runID argument value.
			RunID string
		}
		// DescribeTaskQueue holds details about calls to the DescribeTaskQueue method.
		DescribeTaskQueue []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TaskQueue is the taskQueue argument value.
			TaskQueue string
			// TaskQueueType is the taskQueueType argument value.
			TaskQueueType enums.TaskQueueType
		}
		// ExecuteWorkflow holds details about calls to the ExecuteWorkflow method.
		ExecuteWorkflow []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Options is the options argument value.
			Options client.StartWorkflowOptions
			// Workflow is the workflow argument value.
			Workflow interface{}
			// Args is the args argument value.
			Args []interface{}
		}
		// GetWorkflow holds details about calls to the GetWorkflow method.
		GetWorkflow []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkflowID is the workflowID argument value.
			WorkflowID string
			// RunID is the runID argument value.
			RunID string
		}
		// GetWorkflowHistory holds details about calls to the GetWorkflowHistory method.
		GetWorkflowHistory []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkflowID is the workflowID argument value.
			WorkflowID string
			// RunID is the runID argument value.
			RunID string
			// IsLongPoll is the isLongPoll argument value.
			IsLongPoll bool
			// FilterType is the filterType argument value.
			FilterType enums.HistoryEventFilterType
		}
		// ResetWorkflowExecution holds details about calls to the ResetWorkflowExecution method.
		ResetWorkflowExecution []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Request is the request argument value.
			Request *workflowservice.ResetWorkflowExecutionRequest
		}
	}
	lockCancelWorkflow         sync.RWMutex
	lockDescribeTaskQueue      sync.RWMutex
	lockExecuteWorkflow        sync.RWMutex
	lockGetWorkflow            sync.RWMutex
	lockGetWorkflowHistory     sync.RWMutex
	lockResetWorkflowExecution sync.RWMutex
}

// CancelWorkflow calls CancelWorkflowFunc.
func (mock *WorkflowerMock) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	if mock.CancelWorkflowFunc == nil {
		panic("WorkflowerMock.CancelWorkflowFunc: method is nil but Workflower.CancelWorkflow was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		WorkflowID string
		RunID      string
	}{
		Ctx:        ctx,
		WorkflowID: workflowID,
		RunID:      runID,
	}
	mock.lockCancelWorkflow.Lock()
	mock.calls.CancelWorkflow = append(mock.calls.CancelWorkflow, callInfo)
	mock.lockCancelWorkflow.Unlock()
	return mock.CancelWorkflowFunc(ctx, workflowID, runID)
}

// CancelWorkflowCalls gets all the calls that were made to CancelWorkflow.
// Check the length with:
//
//	len(mockedWorkflower.CancelWorkflowCalls())
func (mock *WorkflowerMock) CancelWorkflowCalls() []struct {
	Ctx        context.Context
	WorkflowID string
	RunID      string
} {
	var calls []struct {
		Ctx        context.Context
		WorkflowID string
		RunID      string
	}
	mock.lockCancelWorkflow.RLock()
	calls = mock.calls.CancelWorkflow
	mock.lockCancelWorkflow.RUnlock()
	return calls
}

// DescribeTaskQueue calls DescribeTaskQueueFunc.
func (mock *WorkflowerMock) DescribeTaskQueue(ctx context.Context, taskQueue string, taskQueueType enums.TaskQueueType) (*workflowservice.DescribeTaskQueueResponse, error) {
	if mock.DescribeTaskQueueFunc == nil {
		panic("WorkflowerMock.DescribeTaskQueueFunc: method is nil but Workflower.DescribeTaskQueue was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		TaskQueue     string
		TaskQueueType enums.TaskQueueType
	}{
		Ctx:           ctx,
		TaskQueue:     taskQueue,
		TaskQueueType: taskQueueType,
	}
	mock.lockDescribeTaskQueue.Lock()
	mock.calls.DescribeTaskQueue = append(mock.calls.DescribeTaskQueue, callInfo)
	mock.lockDescribeTaskQueue.Unlock()
	return mock.DescribeTaskQueueFunc(ctx, taskQueue, taskQueueType)
}

// DescribeTaskQueueCalls gets all the calls that were made to DescribeTaskQueue.
// Check the length with:
//
//	len(mockedWorkflower.DescribeTaskQueueCalls())
func (mock *WorkflowerMock) DescribeTaskQueueCalls() []struct {
	Ctx           context.Context
	TaskQueue     string
	TaskQueueType enums.TaskQueueType
} {
	var calls []struct {
		Ctx           context.Context
		TaskQueue     string
		TaskQueueType enums.TaskQueueType
	}
	mock.lockDescribeTaskQueue.RLock()
	calls = mock.calls.DescribeTaskQueue
	mock.lockDescribeTaskQueue.RUnlock()
	return calls
}

// ExecuteWorkflow calls ExecuteWorkflowFunc.
func (mock *WorkflowerMock) ExecuteWorkflow(ctx context.Context, options client.StartWorkflowOptions, workflow interface{}, args ...interface{}) (client.WorkflowRun, error) {
	if mock.ExecuteWorkflowFunc == nil {
		panic("WorkflowerMock.ExecuteWorkflowFunc: method is nil but Workflower.ExecuteWorkflow was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Options  client.StartWorkflowOptions
		Workflow interface{}
		Args     []interface{}
	}{
		Ctx:      ctx,
		Options:  options,
		Workflow: workflow,
		Args:     args,
	}
	mock.lockExecuteWorkflow.Lock()
	mock.calls.ExecuteWorkflow = append(mock.calls.ExecuteWorkflow, callInfo)
	mock.lockExecuteWorkflow.Unlock()
	return mock.ExecuteWorkflowFunc(ctx, options, workflow, args...)
}

// ExecuteWorkflowCalls gets all the calls that were made to ExecuteWorkflow.
// Check the length with:
//
//	len(mockedWorkflower.ExecuteWorkflowCalls())
func (mock *WorkflowerMock) ExecuteWorkflowCalls() []struct {
	Ctx      context.Context
	Options  client.StartWorkflowOptions
	Workflow interface{}
	Args     []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Options  client.StartWorkflowOptions
		Workflow interface{}
		Args     []interface{}
	}
	mock.lockExecuteWorkflow.RLock()
	calls = mock.calls.ExecuteWorkflow
	mock.lockExecuteWorkflow.RUnlock()
	return calls
}

// GetWorkflow calls GetWorkflowFunc.
func (mock *WorkflowerMock) GetWorkflow(ctx context.Context, workflowID string, runID string) client.WorkflowRun {
	if mock.GetWorkflowFunc == nil {
		panic("WorkflowerMock.GetWorkflowFunc: method is nil but Workflower.GetWorkflow was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		WorkflowID string
		RunID      string
	}{
		Ctx:        ctx,
		WorkflowID: workflowID,
		RunID:      runID,
	}
	mock.lockGetWorkflow.Lock()
	mock.calls.GetWorkflow = append(mock.calls.GetWorkflow, callInfo)
	mock.lockGetWorkflow.Unlock()
	return mock.GetWorkflowFunc(ctx, workflowID, runID)
}

// GetWorkflowCalls gets all the calls that were made to GetWorkflow.
// Check the length with:
//
//	len(mockedWorkflower.GetWorkflowCalls())
func (mock *WorkflowerMock) GetWorkflowCalls() []struct {
	Ctx        context.Context
	WorkflowID string
	RunID      string
} {
	var calls []struct {
		Ctx        context.Context
		WorkflowID string
		RunID      string
	}
	mock.lockGetWorkflow.RLock()
	calls = mock.calls.GetWorkflow
	mock.lockGetWorkflow.RUnlock()
	return calls
}

// GetWorkflowHistory calls GetWorkflowHistoryFunc.
func (mock *WorkflowerMock) GetWorkflowHistory(ctx context.Context, workflowID string, runID string, isLongPoll bool, filterType enums.HistoryEventFilterType) client.HistoryEventIterator {
	if mock.GetWorkflowHistoryFunc == nil {
		panic("WorkflowerMock.GetWorkflowHistoryFunc: method is nil but Workflower.GetWorkflowHistory was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		WorkflowID string
		RunID      string
		IsLongPoll bool
		FilterType enums.HistoryEventFilterType
	}{
		Ctx:        ctx,
		WorkflowID: workflowID,
		RunID:      runID,
		IsLongPoll: isLongPoll,
		FilterType: filterType,
	}
	mock.lockGetWorkflowHistory.Lock()
	mock.calls.GetWorkflowHistory = append(mock.calls.GetWorkflowHistory, callInfo)
	mock.lockGetWorkflowHistory.Unlock()
	return mock.GetWorkflowHistoryFunc(ctx, workflowID, runID, isLongPoll, filterType)
}

// GetWorkflowHistoryCalls gets all the calls that were made to GetWorkflowHistory.
// Check the length with:
//
//	len(mockedWorkflower.GetWorkflowHistoryCalls())
func (mock *WorkflowerMock) GetWorkflowHistoryCalls() []struct {
	Ctx        context.Context
	WorkflowID string
	RunID      string
	IsLongPoll bool
	FilterType enums.HistoryEventFilterType
} {
	var calls []struct {
		Ctx        context.Context
		WorkflowID string
		RunID      string
		IsLongPoll bool
		FilterType enums.HistoryEventFilterType
	}
	mock.lockGetWorkflowHistory.RLock()
	calls = mock.calls.GetWorkflowHistory
	mock.lockGetWorkflowHistory.RUnlock()
	return calls
}

// ResetWorkflowExecution calls ResetWorkflowExecutionFunc.
func (mock *WorkflowerMock) ResetWorkflowExecution(ctx context.Context, request *workflowservice.ResetWorkflowExecutionRequest) (*workflowservice.ResetWorkflowExecutionResponse, error) {
	if mock.ResetWorkflowExecutionFunc == nil {
		panic("WorkflowerMock.ResetWorkflowExecutionFunc: method is nil but Workflower.ResetWorkflowExecution was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Request *workflowservice.ResetWorkflowExecutionRequest
	}{
		Ctx:     ctx,
		Request: request,
	}
	mock.lockResetWorkflowExecution.Lock()
	mock.calls.ResetWorkflowExecution = append(mock.calls.ResetWorkflowExecution, callInfo)
	mock.lockResetWorkflowExecution.Unlock()
	return mock.ResetWorkflowExecutionFunc(ctx, request)
}

// ResetWorkflowExecutionCalls gets all the calls that were made to ResetWorkflowExecution.
// Check the length with:
//
//	len(mockedWorkflower.ResetWorkflowExecutionCalls())
func (mock *WorkflowerMock) ResetWorkflowExecutionCalls() []struct {
	Ctx     context.Context
	Request *workflowservice.ResetWorkflowExecutionRequest
} {
	var calls []struct {
		Ctx     context.Context
		Request *workflowservice.ResetWorkflowExecutionRequest
	}
	mock.lockResetWorkflowExecution.RLock()
	calls = mock.calls.ResetWorkflowExecution
	mock.lockResetWorkflowExecution.RUnlock()
	return calls
}
