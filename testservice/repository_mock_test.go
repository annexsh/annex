// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package testservice

import (
	"context"
	"github.com/annexsh/annex/test"
	"github.com/annexsh/annex/uuid"
	"sync"
	"time"
)

// Ensure, that RepositoryMock does implement test.Repository.
// If this is not the case, regenerate this file with moq.
var _ test.Repository = &RepositoryMock{}

// RepositoryMock is a mock implementation of test.Repository.
//
//	func TestSomethingThatUsesRepository(t *testing.T) {
//
//		// make and configure a mocked test.Repository
//		mockedRepository := &RepositoryMock{
//			CreateCaseExecutionScheduledFunc: func(ctx context.Context, scheduled *test.ScheduledCaseExecution) (*test.CaseExecution, error) {
//				panic("mock out the CreateCaseExecutionScheduled method")
//			},
//			CreateContextFunc: func(ctx context.Context, id string) error {
//				panic("mock out the CreateContext method")
//			},
//			CreateLogFunc: func(ctx context.Context, log *test.Log) error {
//				panic("mock out the CreateLog method")
//			},
//			CreateTestFunc: func(ctx context.Context, testMoqParam *test.Test) (*test.Test, error) {
//				panic("mock out the CreateTest method")
//			},
//			CreateTestDefaultInputFunc: func(ctx context.Context, testID uuid.V7, defaultInput *test.Payload) error {
//				panic("mock out the CreateTestDefaultInput method")
//			},
//			CreateTestExecutionInputFunc: func(ctx context.Context, testExecID test.TestExecutionID, input *test.Payload) error {
//				panic("mock out the CreateTestExecutionInput method")
//			},
//			CreateTestExecutionScheduledFunc: func(ctx context.Context, scheduled *test.ScheduledTestExecution) (*test.TestExecution, error) {
//				panic("mock out the CreateTestExecutionScheduled method")
//			},
//			CreateTestSuiteFunc: func(ctx context.Context, testSuite *test.TestSuite) (uuid.V7, error) {
//				panic("mock out the CreateTestSuite method")
//			},
//			DeleteCaseExecutionFunc: func(ctx context.Context, testExecID test.TestExecutionID, id test.CaseExecutionID) error {
//				panic("mock out the DeleteCaseExecution method")
//			},
//			DeleteLogFunc: func(ctx context.Context, id uuid.V7) error {
//				panic("mock out the DeleteLog method")
//			},
//			DeleteTestFunc: func(ctx context.Context, id uuid.V7) error {
//				panic("mock out the DeleteTest method")
//			},
//			ExecuteTxFunc: func(ctx context.Context, query func(repo test.Repository) error) error {
//				panic("mock out the ExecuteTx method")
//			},
//			GetCaseExecutionFunc: func(ctx context.Context, testExecID test.TestExecutionID, caseExecID test.CaseExecutionID) (*test.CaseExecution, error) {
//				panic("mock out the GetCaseExecution method")
//			},
//			GetLogFunc: func(ctx context.Context, id uuid.V7) (*test.Log, error) {
//				panic("mock out the GetLog method")
//			},
//			GetTestFunc: func(ctx context.Context, id uuid.V7) (*test.Test, error) {
//				panic("mock out the GetTest method")
//			},
//			GetTestDefaultInputFunc: func(ctx context.Context, testID uuid.V7) (*test.Payload, error) {
//				panic("mock out the GetTestDefaultInput method")
//			},
//			GetTestExecutionFunc: func(ctx context.Context, id test.TestExecutionID) (*test.TestExecution, error) {
//				panic("mock out the GetTestExecution method")
//			},
//			GetTestExecutionInputFunc: func(ctx context.Context, id test.TestExecutionID) (*test.Payload, error) {
//				panic("mock out the GetTestExecutionInput method")
//			},
//			GetTestSuiteVersionFunc: func(ctx context.Context, contextID string, id uuid.V7) (string, error) {
//				panic("mock out the GetTestSuiteVersion method")
//			},
//			ListCaseExecutionsFunc: func(ctx context.Context, testExecID test.TestExecutionID, filter test.PageFilter[test.CaseExecutionID]) (test.CaseExecutionList, error) {
//				panic("mock out the ListCaseExecutions method")
//			},
//			ListContextsFunc: func(ctx context.Context, filter test.PageFilter[string]) ([]string, error) {
//				panic("mock out the ListContexts method")
//			},
//			ListLogsFunc: func(ctx context.Context, testExecID test.TestExecutionID, filter test.PageFilter[uuid.V7]) (test.LogList, error) {
//				panic("mock out the ListLogs method")
//			},
//			ListTestExecutionsFunc: func(ctx context.Context, testID uuid.V7, filter test.PageFilter[test.TestExecutionID]) (test.TestExecutionList, error) {
//				panic("mock out the ListTestExecutions method")
//			},
//			ListTestSuitesFunc: func(ctx context.Context, contextID string, filter test.PageFilter[string]) (test.TestSuiteList, error) {
//				panic("mock out the ListTestSuites method")
//			},
//			ListTestsFunc: func(ctx context.Context, contextID string, testSuiteID uuid.V7, filter test.PageFilter[uuid.V7]) (test.TestList, error) {
//				panic("mock out the ListTests method")
//			},
//			ResetTestExecutionFunc: func(ctx context.Context, testExecID test.TestExecutionID, resetTime time.Time) (*test.TestExecution, error) {
//				panic("mock out the ResetTestExecution method")
//			},
//			UpdateCaseExecutionFinishedFunc: func(ctx context.Context, finished *test.FinishedCaseExecution) (*test.CaseExecution, error) {
//				panic("mock out the UpdateCaseExecutionFinished method")
//			},
//			UpdateCaseExecutionStartedFunc: func(ctx context.Context, started *test.StartedCaseExecution) (*test.CaseExecution, error) {
//				panic("mock out the UpdateCaseExecutionStarted method")
//			},
//			UpdateTestExecutionFinishedFunc: func(ctx context.Context, finished *test.FinishedTestExecution) (*test.TestExecution, error) {
//				panic("mock out the UpdateTestExecutionFinished method")
//			},
//			UpdateTestExecutionStartedFunc: func(ctx context.Context, started *test.StartedTestExecution) (*test.TestExecution, error) {
//				panic("mock out the UpdateTestExecutionStarted method")
//			},
//			WithTxFunc: func(ctx context.Context) (test.Repository, test.Tx, error) {
//				panic("mock out the WithTx method")
//			},
//		}
//
//		// use mockedRepository in code that requires test.Repository
//		// and then make assertions.
//
//	}
type RepositoryMock struct {
	// CreateCaseExecutionScheduledFunc mocks the CreateCaseExecutionScheduled method.
	CreateCaseExecutionScheduledFunc func(ctx context.Context, scheduled *test.ScheduledCaseExecution) (*test.CaseExecution, error)

	// CreateContextFunc mocks the CreateContext method.
	CreateContextFunc func(ctx context.Context, id string) error

	// CreateLogFunc mocks the CreateLog method.
	CreateLogFunc func(ctx context.Context, log *test.Log) error

	// CreateTestFunc mocks the CreateTest method.
	CreateTestFunc func(ctx context.Context, testMoqParam *test.Test) (*test.Test, error)

	// CreateTestDefaultInputFunc mocks the CreateTestDefaultInput method.
	CreateTestDefaultInputFunc func(ctx context.Context, testID uuid.V7, defaultInput *test.Payload) error

	// CreateTestExecutionInputFunc mocks the CreateTestExecutionInput method.
	CreateTestExecutionInputFunc func(ctx context.Context, testExecID test.TestExecutionID, input *test.Payload) error

	// CreateTestExecutionScheduledFunc mocks the CreateTestExecutionScheduled method.
	CreateTestExecutionScheduledFunc func(ctx context.Context, scheduled *test.ScheduledTestExecution) (*test.TestExecution, error)

	// CreateTestSuiteFunc mocks the CreateTestSuite method.
	CreateTestSuiteFunc func(ctx context.Context, testSuite *test.TestSuite) (uuid.V7, error)

	// DeleteCaseExecutionFunc mocks the DeleteCaseExecution method.
	DeleteCaseExecutionFunc func(ctx context.Context, testExecID test.TestExecutionID, id test.CaseExecutionID) error

	// DeleteLogFunc mocks the DeleteLog method.
	DeleteLogFunc func(ctx context.Context, id uuid.V7) error

	// DeleteTestFunc mocks the DeleteTest method.
	DeleteTestFunc func(ctx context.Context, id uuid.V7) error

	// ExecuteTxFunc mocks the ExecuteTx method.
	ExecuteTxFunc func(ctx context.Context, query func(repo test.Repository) error) error

	// GetCaseExecutionFunc mocks the GetCaseExecution method.
	GetCaseExecutionFunc func(ctx context.Context, testExecID test.TestExecutionID, caseExecID test.CaseExecutionID) (*test.CaseExecution, error)

	// GetLogFunc mocks the GetLog method.
	GetLogFunc func(ctx context.Context, id uuid.V7) (*test.Log, error)

	// GetTestFunc mocks the GetTest method.
	GetTestFunc func(ctx context.Context, id uuid.V7) (*test.Test, error)

	// GetTestDefaultInputFunc mocks the GetTestDefaultInput method.
	GetTestDefaultInputFunc func(ctx context.Context, testID uuid.V7) (*test.Payload, error)

	// GetTestExecutionFunc mocks the GetTestExecution method.
	GetTestExecutionFunc func(ctx context.Context, id test.TestExecutionID) (*test.TestExecution, error)

	// GetTestExecutionInputFunc mocks the GetTestExecutionInput method.
	GetTestExecutionInputFunc func(ctx context.Context, id test.TestExecutionID) (*test.Payload, error)

	// GetTestSuiteVersionFunc mocks the GetTestSuiteVersion method.
	GetTestSuiteVersionFunc func(ctx context.Context, contextID string, id uuid.V7) (string, error)

	// ListCaseExecutionsFunc mocks the ListCaseExecutions method.
	ListCaseExecutionsFunc func(ctx context.Context, testExecID test.TestExecutionID, filter test.PageFilter[test.CaseExecutionID]) (test.CaseExecutionList, error)

	// ListContextsFunc mocks the ListContexts method.
	ListContextsFunc func(ctx context.Context, filter test.PageFilter[string]) ([]string, error)

	// ListLogsFunc mocks the ListLogs method.
	ListLogsFunc func(ctx context.Context, testExecID test.TestExecutionID, filter test.PageFilter[uuid.V7]) (test.LogList, error)

	// ListTestExecutionsFunc mocks the ListTestExecutions method.
	ListTestExecutionsFunc func(ctx context.Context, testID uuid.V7, filter test.PageFilter[test.TestExecutionID]) (test.TestExecutionList, error)

	// ListTestSuitesFunc mocks the ListTestSuites method.
	ListTestSuitesFunc func(ctx context.Context, contextID string, filter test.PageFilter[string]) (test.TestSuiteList, error)

	// ListTestsFunc mocks the ListTests method.
	ListTestsFunc func(ctx context.Context, contextID string, testSuiteID uuid.V7, filter test.PageFilter[uuid.V7]) (test.TestList, error)

	// ResetTestExecutionFunc mocks the ResetTestExecution method.
	ResetTestExecutionFunc func(ctx context.Context, testExecID test.TestExecutionID, resetTime time.Time) (*test.TestExecution, error)

	// UpdateCaseExecutionFinishedFunc mocks the UpdateCaseExecutionFinished method.
	UpdateCaseExecutionFinishedFunc func(ctx context.Context, finished *test.FinishedCaseExecution) (*test.CaseExecution, error)

	// UpdateCaseExecutionStartedFunc mocks the UpdateCaseExecutionStarted method.
	UpdateCaseExecutionStartedFunc func(ctx context.Context, started *test.StartedCaseExecution) (*test.CaseExecution, error)

	// UpdateTestExecutionFinishedFunc mocks the UpdateTestExecutionFinished method.
	UpdateTestExecutionFinishedFunc func(ctx context.Context, finished *test.FinishedTestExecution) (*test.TestExecution, error)

	// UpdateTestExecutionStartedFunc mocks the UpdateTestExecutionStarted method.
	UpdateTestExecutionStartedFunc func(ctx context.Context, started *test.StartedTestExecution) (*test.TestExecution, error)

	// WithTxFunc mocks the WithTx method.
	WithTxFunc func(ctx context.Context) (test.Repository, test.Tx, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateCaseExecutionScheduled holds details about calls to the CreateCaseExecutionScheduled method.
		CreateCaseExecutionScheduled []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Scheduled is the scheduled argument value.
			Scheduled *test.ScheduledCaseExecution
		}
		// CreateContext holds details about calls to the CreateContext method.
		CreateContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// CreateLog holds details about calls to the CreateLog method.
		CreateLog []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Log is the log argument value.
			Log *test.Log
		}
		// CreateTest holds details about calls to the CreateTest method.
		CreateTest []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TestMoqParam is the testMoqParam argument value.
			TestMoqParam *test.Test
		}
		// CreateTestDefaultInput holds details about calls to the CreateTestDefaultInput method.
		CreateTestDefaultInput []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TestID is the testID argument value.
			TestID uuid.V7
			// DefaultInput is the defaultInput argument value.
			DefaultInput *test.Payload
		}
		// CreateTestExecutionInput holds details about calls to the CreateTestExecutionInput method.
		CreateTestExecutionInput []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TestExecID is the testExecID argument value.
			TestExecID test.TestExecutionID
			// Input is the input argument value.
			Input *test.Payload
		}
		// CreateTestExecutionScheduled holds details about calls to the CreateTestExecutionScheduled method.
		CreateTestExecutionScheduled []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Scheduled is the scheduled argument value.
			Scheduled *test.ScheduledTestExecution
		}
		// CreateTestSuite holds details about calls to the CreateTestSuite method.
		CreateTestSuite []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TestSuite is the testSuite argument value.
			TestSuite *test.TestSuite
		}
		// DeleteCaseExecution holds details about calls to the DeleteCaseExecution method.
		DeleteCaseExecution []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TestExecID is the testExecID argument value.
			TestExecID test.TestExecutionID
			// ID is the id argument value.
			ID test.CaseExecutionID
		}
		// DeleteLog holds details about calls to the DeleteLog method.
		DeleteLog []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.V7
		}
		// DeleteTest holds details about calls to the DeleteTest method.
		DeleteTest []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.V7
		}
		// ExecuteTx holds details about calls to the ExecuteTx method.
		ExecuteTx []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Query is the query argument value.
			Query func(repo test.Repository) error
		}
		// GetCaseExecution holds details about calls to the GetCaseExecution method.
		GetCaseExecution []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TestExecID is the testExecID argument value.
			TestExecID test.TestExecutionID
			// CaseExecID is the caseExecID argument value.
			CaseExecID test.CaseExecutionID
		}
		// GetLog holds details about calls to the GetLog method.
		GetLog []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.V7
		}
		// GetTest holds details about calls to the GetTest method.
		GetTest []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.V7
		}
		// GetTestDefaultInput holds details about calls to the GetTestDefaultInput method.
		GetTestDefaultInput []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TestID is the testID argument value.
			TestID uuid.V7
		}
		// GetTestExecution holds details about calls to the GetTestExecution method.
		GetTestExecution []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID test.TestExecutionID
		}
		// GetTestExecutionInput holds details about calls to the GetTestExecutionInput method.
		GetTestExecutionInput []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID test.TestExecutionID
		}
		// GetTestSuiteVersion holds details about calls to the GetTestSuiteVersion method.
		GetTestSuiteVersion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ContextID is the contextID argument value.
			ContextID string
			// ID is the id argument value.
			ID uuid.V7
		}
		// ListCaseExecutions holds details about calls to the ListCaseExecutions method.
		ListCaseExecutions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TestExecID is the testExecID argument value.
			TestExecID test.TestExecutionID
			// Filter is the filter argument value.
			Filter test.PageFilter[test.CaseExecutionID]
		}
		// ListContexts holds details about calls to the ListContexts method.
		ListContexts []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Filter is the filter argument value.
			Filter test.PageFilter[string]
		}
		// ListLogs holds details about calls to the ListLogs method.
		ListLogs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TestExecID is the testExecID argument value.
			TestExecID test.TestExecutionID
			// Filter is the filter argument value.
			Filter test.PageFilter[uuid.V7]
		}
		// ListTestExecutions holds details about calls to the ListTestExecutions method.
		ListTestExecutions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TestID is the testID argument value.
			TestID uuid.V7
			// Filter is the filter argument value.
			Filter test.PageFilter[test.TestExecutionID]
		}
		// ListTestSuites holds details about calls to the ListTestSuites method.
		ListTestSuites []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ContextID is the contextID argument value.
			ContextID string
			// Filter is the filter argument value.
			Filter test.PageFilter[string]
		}
		// ListTests holds details about calls to the ListTests method.
		ListTests []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ContextID is the contextID argument value.
			ContextID string
			// TestSuiteID is the testSuiteID argument value.
			TestSuiteID uuid.V7
			// Filter is the filter argument value.
			Filter test.PageFilter[uuid.V7]
		}
		// ResetTestExecution holds details about calls to the ResetTestExecution method.
		ResetTestExecution []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TestExecID is the testExecID argument value.
			TestExecID test.TestExecutionID
			// ResetTime is the resetTime argument value.
			ResetTime time.Time
		}
		// UpdateCaseExecutionFinished holds details about calls to the UpdateCaseExecutionFinished method.
		UpdateCaseExecutionFinished []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Finished is the finished argument value.
			Finished *test.FinishedCaseExecution
		}
		// UpdateCaseExecutionStarted holds details about calls to the UpdateCaseExecutionStarted method.
		UpdateCaseExecutionStarted []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Started is the started argument value.
			Started *test.StartedCaseExecution
		}
		// UpdateTestExecutionFinished holds details about calls to the UpdateTestExecutionFinished method.
		UpdateTestExecutionFinished []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Finished is the finished argument value.
			Finished *test.FinishedTestExecution
		}
		// UpdateTestExecutionStarted holds details about calls to the UpdateTestExecutionStarted method.
		UpdateTestExecutionStarted []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Started is the started argument value.
			Started *test.StartedTestExecution
		}
		// WithTx holds details about calls to the WithTx method.
		WithTx []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockCreateCaseExecutionScheduled sync.RWMutex
	lockCreateContext                sync.RWMutex
	lockCreateLog                    sync.RWMutex
	lockCreateTest                   sync.RWMutex
	lockCreateTestDefaultInput       sync.RWMutex
	lockCreateTestExecutionInput     sync.RWMutex
	lockCreateTestExecutionScheduled sync.RWMutex
	lockCreateTestSuite              sync.RWMutex
	lockDeleteCaseExecution          sync.RWMutex
	lockDeleteLog                    sync.RWMutex
	lockDeleteTest                   sync.RWMutex
	lockExecuteTx                    sync.RWMutex
	lockGetCaseExecution             sync.RWMutex
	lockGetLog                       sync.RWMutex
	lockGetTest                      sync.RWMutex
	lockGetTestDefaultInput          sync.RWMutex
	lockGetTestExecution             sync.RWMutex
	lockGetTestExecutionInput        sync.RWMutex
	lockGetTestSuiteVersion          sync.RWMutex
	lockListCaseExecutions           sync.RWMutex
	lockListContexts                 sync.RWMutex
	lockListLogs                     sync.RWMutex
	lockListTestExecutions           sync.RWMutex
	lockListTestSuites               sync.RWMutex
	lockListTests                    sync.RWMutex
	lockResetTestExecution           sync.RWMutex
	lockUpdateCaseExecutionFinished  sync.RWMutex
	lockUpdateCaseExecutionStarted   sync.RWMutex
	lockUpdateTestExecutionFinished  sync.RWMutex
	lockUpdateTestExecutionStarted   sync.RWMutex
	lockWithTx                       sync.RWMutex
}

// CreateCaseExecutionScheduled calls CreateCaseExecutionScheduledFunc.
func (mock *RepositoryMock) CreateCaseExecutionScheduled(ctx context.Context, scheduled *test.ScheduledCaseExecution) (*test.CaseExecution, error) {
	if mock.CreateCaseExecutionScheduledFunc == nil {
		panic("RepositoryMock.CreateCaseExecutionScheduledFunc: method is nil but Repository.CreateCaseExecutionScheduled was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Scheduled *test.ScheduledCaseExecution
	}{
		Ctx:       ctx,
		Scheduled: scheduled,
	}
	mock.lockCreateCaseExecutionScheduled.Lock()
	mock.calls.CreateCaseExecutionScheduled = append(mock.calls.CreateCaseExecutionScheduled, callInfo)
	mock.lockCreateCaseExecutionScheduled.Unlock()
	return mock.CreateCaseExecutionScheduledFunc(ctx, scheduled)
}

// CreateCaseExecutionScheduledCalls gets all the calls that were made to CreateCaseExecutionScheduled.
// Check the length with:
//
//	len(mockedRepository.CreateCaseExecutionScheduledCalls())
func (mock *RepositoryMock) CreateCaseExecutionScheduledCalls() []struct {
	Ctx       context.Context
	Scheduled *test.ScheduledCaseExecution
} {
	var calls []struct {
		Ctx       context.Context
		Scheduled *test.ScheduledCaseExecution
	}
	mock.lockCreateCaseExecutionScheduled.RLock()
	calls = mock.calls.CreateCaseExecutionScheduled
	mock.lockCreateCaseExecutionScheduled.RUnlock()
	return calls
}

// CreateContext calls CreateContextFunc.
func (mock *RepositoryMock) CreateContext(ctx context.Context, id string) error {
	if mock.CreateContextFunc == nil {
		panic("RepositoryMock.CreateContextFunc: method is nil but Repository.CreateContext was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockCreateContext.Lock()
	mock.calls.CreateContext = append(mock.calls.CreateContext, callInfo)
	mock.lockCreateContext.Unlock()
	return mock.CreateContextFunc(ctx, id)
}

// CreateContextCalls gets all the calls that were made to CreateContext.
// Check the length with:
//
//	len(mockedRepository.CreateContextCalls())
func (mock *RepositoryMock) CreateContextCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockCreateContext.RLock()
	calls = mock.calls.CreateContext
	mock.lockCreateContext.RUnlock()
	return calls
}

// CreateLog calls CreateLogFunc.
func (mock *RepositoryMock) CreateLog(ctx context.Context, log *test.Log) error {
	if mock.CreateLogFunc == nil {
		panic("RepositoryMock.CreateLogFunc: method is nil but Repository.CreateLog was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Log *test.Log
	}{
		Ctx: ctx,
		Log: log,
	}
	mock.lockCreateLog.Lock()
	mock.calls.CreateLog = append(mock.calls.CreateLog, callInfo)
	mock.lockCreateLog.Unlock()
	return mock.CreateLogFunc(ctx, log)
}

// CreateLogCalls gets all the calls that were made to CreateLog.
// Check the length with:
//
//	len(mockedRepository.CreateLogCalls())
func (mock *RepositoryMock) CreateLogCalls() []struct {
	Ctx context.Context
	Log *test.Log
} {
	var calls []struct {
		Ctx context.Context
		Log *test.Log
	}
	mock.lockCreateLog.RLock()
	calls = mock.calls.CreateLog
	mock.lockCreateLog.RUnlock()
	return calls
}

// CreateTest calls CreateTestFunc.
func (mock *RepositoryMock) CreateTest(ctx context.Context, testMoqParam *test.Test) (*test.Test, error) {
	if mock.CreateTestFunc == nil {
		panic("RepositoryMock.CreateTestFunc: method is nil but Repository.CreateTest was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		TestMoqParam *test.Test
	}{
		Ctx:          ctx,
		TestMoqParam: testMoqParam,
	}
	mock.lockCreateTest.Lock()
	mock.calls.CreateTest = append(mock.calls.CreateTest, callInfo)
	mock.lockCreateTest.Unlock()
	return mock.CreateTestFunc(ctx, testMoqParam)
}

// CreateTestCalls gets all the calls that were made to CreateTest.
// Check the length with:
//
//	len(mockedRepository.CreateTestCalls())
func (mock *RepositoryMock) CreateTestCalls() []struct {
	Ctx          context.Context
	TestMoqParam *test.Test
} {
	var calls []struct {
		Ctx          context.Context
		TestMoqParam *test.Test
	}
	mock.lockCreateTest.RLock()
	calls = mock.calls.CreateTest
	mock.lockCreateTest.RUnlock()
	return calls
}

// CreateTestDefaultInput calls CreateTestDefaultInputFunc.
func (mock *RepositoryMock) CreateTestDefaultInput(ctx context.Context, testID uuid.V7, defaultInput *test.Payload) error {
	if mock.CreateTestDefaultInputFunc == nil {
		panic("RepositoryMock.CreateTestDefaultInputFunc: method is nil but Repository.CreateTestDefaultInput was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		TestID       uuid.V7
		DefaultInput *test.Payload
	}{
		Ctx:          ctx,
		TestID:       testID,
		DefaultInput: defaultInput,
	}
	mock.lockCreateTestDefaultInput.Lock()
	mock.calls.CreateTestDefaultInput = append(mock.calls.CreateTestDefaultInput, callInfo)
	mock.lockCreateTestDefaultInput.Unlock()
	return mock.CreateTestDefaultInputFunc(ctx, testID, defaultInput)
}

// CreateTestDefaultInputCalls gets all the calls that were made to CreateTestDefaultInput.
// Check the length with:
//
//	len(mockedRepository.CreateTestDefaultInputCalls())
func (mock *RepositoryMock) CreateTestDefaultInputCalls() []struct {
	Ctx          context.Context
	TestID       uuid.V7
	DefaultInput *test.Payload
} {
	var calls []struct {
		Ctx          context.Context
		TestID       uuid.V7
		DefaultInput *test.Payload
	}
	mock.lockCreateTestDefaultInput.RLock()
	calls = mock.calls.CreateTestDefaultInput
	mock.lockCreateTestDefaultInput.RUnlock()
	return calls
}

// CreateTestExecutionInput calls CreateTestExecutionInputFunc.
func (mock *RepositoryMock) CreateTestExecutionInput(ctx context.Context, testExecID test.TestExecutionID, input *test.Payload) error {
	if mock.CreateTestExecutionInputFunc == nil {
		panic("RepositoryMock.CreateTestExecutionInputFunc: method is nil but Repository.CreateTestExecutionInput was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		TestExecID test.TestExecutionID
		Input      *test.Payload
	}{
		Ctx:        ctx,
		TestExecID: testExecID,
		Input:      input,
	}
	mock.lockCreateTestExecutionInput.Lock()
	mock.calls.CreateTestExecutionInput = append(mock.calls.CreateTestExecutionInput, callInfo)
	mock.lockCreateTestExecutionInput.Unlock()
	return mock.CreateTestExecutionInputFunc(ctx, testExecID, input)
}

// CreateTestExecutionInputCalls gets all the calls that were made to CreateTestExecutionInput.
// Check the length with:
//
//	len(mockedRepository.CreateTestExecutionInputCalls())
func (mock *RepositoryMock) CreateTestExecutionInputCalls() []struct {
	Ctx        context.Context
	TestExecID test.TestExecutionID
	Input      *test.Payload
} {
	var calls []struct {
		Ctx        context.Context
		TestExecID test.TestExecutionID
		Input      *test.Payload
	}
	mock.lockCreateTestExecutionInput.RLock()
	calls = mock.calls.CreateTestExecutionInput
	mock.lockCreateTestExecutionInput.RUnlock()
	return calls
}

// CreateTestExecutionScheduled calls CreateTestExecutionScheduledFunc.
func (mock *RepositoryMock) CreateTestExecutionScheduled(ctx context.Context, scheduled *test.ScheduledTestExecution) (*test.TestExecution, error) {
	if mock.CreateTestExecutionScheduledFunc == nil {
		panic("RepositoryMock.CreateTestExecutionScheduledFunc: method is nil but Repository.CreateTestExecutionScheduled was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Scheduled *test.ScheduledTestExecution
	}{
		Ctx:       ctx,
		Scheduled: scheduled,
	}
	mock.lockCreateTestExecutionScheduled.Lock()
	mock.calls.CreateTestExecutionScheduled = append(mock.calls.CreateTestExecutionScheduled, callInfo)
	mock.lockCreateTestExecutionScheduled.Unlock()
	return mock.CreateTestExecutionScheduledFunc(ctx, scheduled)
}

// CreateTestExecutionScheduledCalls gets all the calls that were made to CreateTestExecutionScheduled.
// Check the length with:
//
//	len(mockedRepository.CreateTestExecutionScheduledCalls())
func (mock *RepositoryMock) CreateTestExecutionScheduledCalls() []struct {
	Ctx       context.Context
	Scheduled *test.ScheduledTestExecution
} {
	var calls []struct {
		Ctx       context.Context
		Scheduled *test.ScheduledTestExecution
	}
	mock.lockCreateTestExecutionScheduled.RLock()
	calls = mock.calls.CreateTestExecutionScheduled
	mock.lockCreateTestExecutionScheduled.RUnlock()
	return calls
}

// CreateTestSuite calls CreateTestSuiteFunc.
func (mock *RepositoryMock) CreateTestSuite(ctx context.Context, testSuite *test.TestSuite) (uuid.V7, error) {
	if mock.CreateTestSuiteFunc == nil {
		panic("RepositoryMock.CreateTestSuiteFunc: method is nil but Repository.CreateTestSuite was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		TestSuite *test.TestSuite
	}{
		Ctx:       ctx,
		TestSuite: testSuite,
	}
	mock.lockCreateTestSuite.Lock()
	mock.calls.CreateTestSuite = append(mock.calls.CreateTestSuite, callInfo)
	mock.lockCreateTestSuite.Unlock()
	return mock.CreateTestSuiteFunc(ctx, testSuite)
}

// CreateTestSuiteCalls gets all the calls that were made to CreateTestSuite.
// Check the length with:
//
//	len(mockedRepository.CreateTestSuiteCalls())
func (mock *RepositoryMock) CreateTestSuiteCalls() []struct {
	Ctx       context.Context
	TestSuite *test.TestSuite
} {
	var calls []struct {
		Ctx       context.Context
		TestSuite *test.TestSuite
	}
	mock.lockCreateTestSuite.RLock()
	calls = mock.calls.CreateTestSuite
	mock.lockCreateTestSuite.RUnlock()
	return calls
}

// DeleteCaseExecution calls DeleteCaseExecutionFunc.
func (mock *RepositoryMock) DeleteCaseExecution(ctx context.Context, testExecID test.TestExecutionID, id test.CaseExecutionID) error {
	if mock.DeleteCaseExecutionFunc == nil {
		panic("RepositoryMock.DeleteCaseExecutionFunc: method is nil but Repository.DeleteCaseExecution was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		TestExecID test.TestExecutionID
		ID         test.CaseExecutionID
	}{
		Ctx:        ctx,
		TestExecID: testExecID,
		ID:         id,
	}
	mock.lockDeleteCaseExecution.Lock()
	mock.calls.DeleteCaseExecution = append(mock.calls.DeleteCaseExecution, callInfo)
	mock.lockDeleteCaseExecution.Unlock()
	return mock.DeleteCaseExecutionFunc(ctx, testExecID, id)
}

// DeleteCaseExecutionCalls gets all the calls that were made to DeleteCaseExecution.
// Check the length with:
//
//	len(mockedRepository.DeleteCaseExecutionCalls())
func (mock *RepositoryMock) DeleteCaseExecutionCalls() []struct {
	Ctx        context.Context
	TestExecID test.TestExecutionID
	ID         test.CaseExecutionID
} {
	var calls []struct {
		Ctx        context.Context
		TestExecID test.TestExecutionID
		ID         test.CaseExecutionID
	}
	mock.lockDeleteCaseExecution.RLock()
	calls = mock.calls.DeleteCaseExecution
	mock.lockDeleteCaseExecution.RUnlock()
	return calls
}

// DeleteLog calls DeleteLogFunc.
func (mock *RepositoryMock) DeleteLog(ctx context.Context, id uuid.V7) error {
	if mock.DeleteLogFunc == nil {
		panic("RepositoryMock.DeleteLogFunc: method is nil but Repository.DeleteLog was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.V7
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteLog.Lock()
	mock.calls.DeleteLog = append(mock.calls.DeleteLog, callInfo)
	mock.lockDeleteLog.Unlock()
	return mock.DeleteLogFunc(ctx, id)
}

// DeleteLogCalls gets all the calls that were made to DeleteLog.
// Check the length with:
//
//	len(mockedRepository.DeleteLogCalls())
func (mock *RepositoryMock) DeleteLogCalls() []struct {
	Ctx context.Context
	ID  uuid.V7
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.V7
	}
	mock.lockDeleteLog.RLock()
	calls = mock.calls.DeleteLog
	mock.lockDeleteLog.RUnlock()
	return calls
}

// DeleteTest calls DeleteTestFunc.
func (mock *RepositoryMock) DeleteTest(ctx context.Context, id uuid.V7) error {
	if mock.DeleteTestFunc == nil {
		panic("RepositoryMock.DeleteTestFunc: method is nil but Repository.DeleteTest was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.V7
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteTest.Lock()
	mock.calls.DeleteTest = append(mock.calls.DeleteTest, callInfo)
	mock.lockDeleteTest.Unlock()
	return mock.DeleteTestFunc(ctx, id)
}

// DeleteTestCalls gets all the calls that were made to DeleteTest.
// Check the length with:
//
//	len(mockedRepository.DeleteTestCalls())
func (mock *RepositoryMock) DeleteTestCalls() []struct {
	Ctx context.Context
	ID  uuid.V7
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.V7
	}
	mock.lockDeleteTest.RLock()
	calls = mock.calls.DeleteTest
	mock.lockDeleteTest.RUnlock()
	return calls
}

// ExecuteTx calls ExecuteTxFunc.
func (mock *RepositoryMock) ExecuteTx(ctx context.Context, query func(repo test.Repository) error) error {
	if mock.ExecuteTxFunc == nil {
		panic("RepositoryMock.ExecuteTxFunc: method is nil but Repository.ExecuteTx was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Query func(repo test.Repository) error
	}{
		Ctx:   ctx,
		Query: query,
	}
	mock.lockExecuteTx.Lock()
	mock.calls.ExecuteTx = append(mock.calls.ExecuteTx, callInfo)
	mock.lockExecuteTx.Unlock()
	return mock.ExecuteTxFunc(ctx, query)
}

// ExecuteTxCalls gets all the calls that were made to ExecuteTx.
// Check the length with:
//
//	len(mockedRepository.ExecuteTxCalls())
func (mock *RepositoryMock) ExecuteTxCalls() []struct {
	Ctx   context.Context
	Query func(repo test.Repository) error
} {
	var calls []struct {
		Ctx   context.Context
		Query func(repo test.Repository) error
	}
	mock.lockExecuteTx.RLock()
	calls = mock.calls.ExecuteTx
	mock.lockExecuteTx.RUnlock()
	return calls
}

// GetCaseExecution calls GetCaseExecutionFunc.
func (mock *RepositoryMock) GetCaseExecution(ctx context.Context, testExecID test.TestExecutionID, caseExecID test.CaseExecutionID) (*test.CaseExecution, error) {
	if mock.GetCaseExecutionFunc == nil {
		panic("RepositoryMock.GetCaseExecutionFunc: method is nil but Repository.GetCaseExecution was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		TestExecID test.TestExecutionID
		CaseExecID test.CaseExecutionID
	}{
		Ctx:        ctx,
		TestExecID: testExecID,
		CaseExecID: caseExecID,
	}
	mock.lockGetCaseExecution.Lock()
	mock.calls.GetCaseExecution = append(mock.calls.GetCaseExecution, callInfo)
	mock.lockGetCaseExecution.Unlock()
	return mock.GetCaseExecutionFunc(ctx, testExecID, caseExecID)
}

// GetCaseExecutionCalls gets all the calls that were made to GetCaseExecution.
// Check the length with:
//
//	len(mockedRepository.GetCaseExecutionCalls())
func (mock *RepositoryMock) GetCaseExecutionCalls() []struct {
	Ctx        context.Context
	TestExecID test.TestExecutionID
	CaseExecID test.CaseExecutionID
} {
	var calls []struct {
		Ctx        context.Context
		TestExecID test.TestExecutionID
		CaseExecID test.CaseExecutionID
	}
	mock.lockGetCaseExecution.RLock()
	calls = mock.calls.GetCaseExecution
	mock.lockGetCaseExecution.RUnlock()
	return calls
}

// GetLog calls GetLogFunc.
func (mock *RepositoryMock) GetLog(ctx context.Context, id uuid.V7) (*test.Log, error) {
	if mock.GetLogFunc == nil {
		panic("RepositoryMock.GetLogFunc: method is nil but Repository.GetLog was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.V7
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetLog.Lock()
	mock.calls.GetLog = append(mock.calls.GetLog, callInfo)
	mock.lockGetLog.Unlock()
	return mock.GetLogFunc(ctx, id)
}

// GetLogCalls gets all the calls that were made to GetLog.
// Check the length with:
//
//	len(mockedRepository.GetLogCalls())
func (mock *RepositoryMock) GetLogCalls() []struct {
	Ctx context.Context
	ID  uuid.V7
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.V7
	}
	mock.lockGetLog.RLock()
	calls = mock.calls.GetLog
	mock.lockGetLog.RUnlock()
	return calls
}

// GetTest calls GetTestFunc.
func (mock *RepositoryMock) GetTest(ctx context.Context, id uuid.V7) (*test.Test, error) {
	if mock.GetTestFunc == nil {
		panic("RepositoryMock.GetTestFunc: method is nil but Repository.GetTest was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.V7
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetTest.Lock()
	mock.calls.GetTest = append(mock.calls.GetTest, callInfo)
	mock.lockGetTest.Unlock()
	return mock.GetTestFunc(ctx, id)
}

// GetTestCalls gets all the calls that were made to GetTest.
// Check the length with:
//
//	len(mockedRepository.GetTestCalls())
func (mock *RepositoryMock) GetTestCalls() []struct {
	Ctx context.Context
	ID  uuid.V7
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.V7
	}
	mock.lockGetTest.RLock()
	calls = mock.calls.GetTest
	mock.lockGetTest.RUnlock()
	return calls
}

// GetTestDefaultInput calls GetTestDefaultInputFunc.
func (mock *RepositoryMock) GetTestDefaultInput(ctx context.Context, testID uuid.V7) (*test.Payload, error) {
	if mock.GetTestDefaultInputFunc == nil {
		panic("RepositoryMock.GetTestDefaultInputFunc: method is nil but Repository.GetTestDefaultInput was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		TestID uuid.V7
	}{
		Ctx:    ctx,
		TestID: testID,
	}
	mock.lockGetTestDefaultInput.Lock()
	mock.calls.GetTestDefaultInput = append(mock.calls.GetTestDefaultInput, callInfo)
	mock.lockGetTestDefaultInput.Unlock()
	return mock.GetTestDefaultInputFunc(ctx, testID)
}

// GetTestDefaultInputCalls gets all the calls that were made to GetTestDefaultInput.
// Check the length with:
//
//	len(mockedRepository.GetTestDefaultInputCalls())
func (mock *RepositoryMock) GetTestDefaultInputCalls() []struct {
	Ctx    context.Context
	TestID uuid.V7
} {
	var calls []struct {
		Ctx    context.Context
		TestID uuid.V7
	}
	mock.lockGetTestDefaultInput.RLock()
	calls = mock.calls.GetTestDefaultInput
	mock.lockGetTestDefaultInput.RUnlock()
	return calls
}

// GetTestExecution calls GetTestExecutionFunc.
func (mock *RepositoryMock) GetTestExecution(ctx context.Context, id test.TestExecutionID) (*test.TestExecution, error) {
	if mock.GetTestExecutionFunc == nil {
		panic("RepositoryMock.GetTestExecutionFunc: method is nil but Repository.GetTestExecution was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  test.TestExecutionID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetTestExecution.Lock()
	mock.calls.GetTestExecution = append(mock.calls.GetTestExecution, callInfo)
	mock.lockGetTestExecution.Unlock()
	return mock.GetTestExecutionFunc(ctx, id)
}

// GetTestExecutionCalls gets all the calls that were made to GetTestExecution.
// Check the length with:
//
//	len(mockedRepository.GetTestExecutionCalls())
func (mock *RepositoryMock) GetTestExecutionCalls() []struct {
	Ctx context.Context
	ID  test.TestExecutionID
} {
	var calls []struct {
		Ctx context.Context
		ID  test.TestExecutionID
	}
	mock.lockGetTestExecution.RLock()
	calls = mock.calls.GetTestExecution
	mock.lockGetTestExecution.RUnlock()
	return calls
}

// GetTestExecutionInput calls GetTestExecutionInputFunc.
func (mock *RepositoryMock) GetTestExecutionInput(ctx context.Context, id test.TestExecutionID) (*test.Payload, error) {
	if mock.GetTestExecutionInputFunc == nil {
		panic("RepositoryMock.GetTestExecutionInputFunc: method is nil but Repository.GetTestExecutionInput was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  test.TestExecutionID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetTestExecutionInput.Lock()
	mock.calls.GetTestExecutionInput = append(mock.calls.GetTestExecutionInput, callInfo)
	mock.lockGetTestExecutionInput.Unlock()
	return mock.GetTestExecutionInputFunc(ctx, id)
}

// GetTestExecutionInputCalls gets all the calls that were made to GetTestExecutionInput.
// Check the length with:
//
//	len(mockedRepository.GetTestExecutionInputCalls())
func (mock *RepositoryMock) GetTestExecutionInputCalls() []struct {
	Ctx context.Context
	ID  test.TestExecutionID
} {
	var calls []struct {
		Ctx context.Context
		ID  test.TestExecutionID
	}
	mock.lockGetTestExecutionInput.RLock()
	calls = mock.calls.GetTestExecutionInput
	mock.lockGetTestExecutionInput.RUnlock()
	return calls
}

// GetTestSuiteVersion calls GetTestSuiteVersionFunc.
func (mock *RepositoryMock) GetTestSuiteVersion(ctx context.Context, contextID string, id uuid.V7) (string, error) {
	if mock.GetTestSuiteVersionFunc == nil {
		panic("RepositoryMock.GetTestSuiteVersionFunc: method is nil but Repository.GetTestSuiteVersion was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ContextID string
		ID        uuid.V7
	}{
		Ctx:       ctx,
		ContextID: contextID,
		ID:        id,
	}
	mock.lockGetTestSuiteVersion.Lock()
	mock.calls.GetTestSuiteVersion = append(mock.calls.GetTestSuiteVersion, callInfo)
	mock.lockGetTestSuiteVersion.Unlock()
	return mock.GetTestSuiteVersionFunc(ctx, contextID, id)
}

// GetTestSuiteVersionCalls gets all the calls that were made to GetTestSuiteVersion.
// Check the length with:
//
//	len(mockedRepository.GetTestSuiteVersionCalls())
func (mock *RepositoryMock) GetTestSuiteVersionCalls() []struct {
	Ctx       context.Context
	ContextID string
	ID        uuid.V7
} {
	var calls []struct {
		Ctx       context.Context
		ContextID string
		ID        uuid.V7
	}
	mock.lockGetTestSuiteVersion.RLock()
	calls = mock.calls.GetTestSuiteVersion
	mock.lockGetTestSuiteVersion.RUnlock()
	return calls
}

// ListCaseExecutions calls ListCaseExecutionsFunc.
func (mock *RepositoryMock) ListCaseExecutions(ctx context.Context, testExecID test.TestExecutionID, filter test.PageFilter[test.CaseExecutionID]) (test.CaseExecutionList, error) {
	if mock.ListCaseExecutionsFunc == nil {
		panic("RepositoryMock.ListCaseExecutionsFunc: method is nil but Repository.ListCaseExecutions was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		TestExecID test.TestExecutionID
		Filter     test.PageFilter[test.CaseExecutionID]
	}{
		Ctx:        ctx,
		TestExecID: testExecID,
		Filter:     filter,
	}
	mock.lockListCaseExecutions.Lock()
	mock.calls.ListCaseExecutions = append(mock.calls.ListCaseExecutions, callInfo)
	mock.lockListCaseExecutions.Unlock()
	return mock.ListCaseExecutionsFunc(ctx, testExecID, filter)
}

// ListCaseExecutionsCalls gets all the calls that were made to ListCaseExecutions.
// Check the length with:
//
//	len(mockedRepository.ListCaseExecutionsCalls())
func (mock *RepositoryMock) ListCaseExecutionsCalls() []struct {
	Ctx        context.Context
	TestExecID test.TestExecutionID
	Filter     test.PageFilter[test.CaseExecutionID]
} {
	var calls []struct {
		Ctx        context.Context
		TestExecID test.TestExecutionID
		Filter     test.PageFilter[test.CaseExecutionID]
	}
	mock.lockListCaseExecutions.RLock()
	calls = mock.calls.ListCaseExecutions
	mock.lockListCaseExecutions.RUnlock()
	return calls
}

// ListContexts calls ListContextsFunc.
func (mock *RepositoryMock) ListContexts(ctx context.Context, filter test.PageFilter[string]) ([]string, error) {
	if mock.ListContextsFunc == nil {
		panic("RepositoryMock.ListContextsFunc: method is nil but Repository.ListContexts was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Filter test.PageFilter[string]
	}{
		Ctx:    ctx,
		Filter: filter,
	}
	mock.lockListContexts.Lock()
	mock.calls.ListContexts = append(mock.calls.ListContexts, callInfo)
	mock.lockListContexts.Unlock()
	return mock.ListContextsFunc(ctx, filter)
}

// ListContextsCalls gets all the calls that were made to ListContexts.
// Check the length with:
//
//	len(mockedRepository.ListContextsCalls())
func (mock *RepositoryMock) ListContextsCalls() []struct {
	Ctx    context.Context
	Filter test.PageFilter[string]
} {
	var calls []struct {
		Ctx    context.Context
		Filter test.PageFilter[string]
	}
	mock.lockListContexts.RLock()
	calls = mock.calls.ListContexts
	mock.lockListContexts.RUnlock()
	return calls
}

// ListLogs calls ListLogsFunc.
func (mock *RepositoryMock) ListLogs(ctx context.Context, testExecID test.TestExecutionID, filter test.PageFilter[uuid.V7]) (test.LogList, error) {
	if mock.ListLogsFunc == nil {
		panic("RepositoryMock.ListLogsFunc: method is nil but Repository.ListLogs was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		TestExecID test.TestExecutionID
		Filter     test.PageFilter[uuid.V7]
	}{
		Ctx:        ctx,
		TestExecID: testExecID,
		Filter:     filter,
	}
	mock.lockListLogs.Lock()
	mock.calls.ListLogs = append(mock.calls.ListLogs, callInfo)
	mock.lockListLogs.Unlock()
	return mock.ListLogsFunc(ctx, testExecID, filter)
}

// ListLogsCalls gets all the calls that were made to ListLogs.
// Check the length with:
//
//	len(mockedRepository.ListLogsCalls())
func (mock *RepositoryMock) ListLogsCalls() []struct {
	Ctx        context.Context
	TestExecID test.TestExecutionID
	Filter     test.PageFilter[uuid.V7]
} {
	var calls []struct {
		Ctx        context.Context
		TestExecID test.TestExecutionID
		Filter     test.PageFilter[uuid.V7]
	}
	mock.lockListLogs.RLock()
	calls = mock.calls.ListLogs
	mock.lockListLogs.RUnlock()
	return calls
}

// ListTestExecutions calls ListTestExecutionsFunc.
func (mock *RepositoryMock) ListTestExecutions(ctx context.Context, testID uuid.V7, filter test.PageFilter[test.TestExecutionID]) (test.TestExecutionList, error) {
	if mock.ListTestExecutionsFunc == nil {
		panic("RepositoryMock.ListTestExecutionsFunc: method is nil but Repository.ListTestExecutions was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		TestID uuid.V7
		Filter test.PageFilter[test.TestExecutionID]
	}{
		Ctx:    ctx,
		TestID: testID,
		Filter: filter,
	}
	mock.lockListTestExecutions.Lock()
	mock.calls.ListTestExecutions = append(mock.calls.ListTestExecutions, callInfo)
	mock.lockListTestExecutions.Unlock()
	return mock.ListTestExecutionsFunc(ctx, testID, filter)
}

// ListTestExecutionsCalls gets all the calls that were made to ListTestExecutions.
// Check the length with:
//
//	len(mockedRepository.ListTestExecutionsCalls())
func (mock *RepositoryMock) ListTestExecutionsCalls() []struct {
	Ctx    context.Context
	TestID uuid.V7
	Filter test.PageFilter[test.TestExecutionID]
} {
	var calls []struct {
		Ctx    context.Context
		TestID uuid.V7
		Filter test.PageFilter[test.TestExecutionID]
	}
	mock.lockListTestExecutions.RLock()
	calls = mock.calls.ListTestExecutions
	mock.lockListTestExecutions.RUnlock()
	return calls
}

// ListTestSuites calls ListTestSuitesFunc.
func (mock *RepositoryMock) ListTestSuites(ctx context.Context, contextID string, filter test.PageFilter[string]) (test.TestSuiteList, error) {
	if mock.ListTestSuitesFunc == nil {
		panic("RepositoryMock.ListTestSuitesFunc: method is nil but Repository.ListTestSuites was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ContextID string
		Filter    test.PageFilter[string]
	}{
		Ctx:       ctx,
		ContextID: contextID,
		Filter:    filter,
	}
	mock.lockListTestSuites.Lock()
	mock.calls.ListTestSuites = append(mock.calls.ListTestSuites, callInfo)
	mock.lockListTestSuites.Unlock()
	return mock.ListTestSuitesFunc(ctx, contextID, filter)
}

// ListTestSuitesCalls gets all the calls that were made to ListTestSuites.
// Check the length with:
//
//	len(mockedRepository.ListTestSuitesCalls())
func (mock *RepositoryMock) ListTestSuitesCalls() []struct {
	Ctx       context.Context
	ContextID string
	Filter    test.PageFilter[string]
} {
	var calls []struct {
		Ctx       context.Context
		ContextID string
		Filter    test.PageFilter[string]
	}
	mock.lockListTestSuites.RLock()
	calls = mock.calls.ListTestSuites
	mock.lockListTestSuites.RUnlock()
	return calls
}

// ListTests calls ListTestsFunc.
func (mock *RepositoryMock) ListTests(ctx context.Context, contextID string, testSuiteID uuid.V7, filter test.PageFilter[uuid.V7]) (test.TestList, error) {
	if mock.ListTestsFunc == nil {
		panic("RepositoryMock.ListTestsFunc: method is nil but Repository.ListTests was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		ContextID   string
		TestSuiteID uuid.V7
		Filter      test.PageFilter[uuid.V7]
	}{
		Ctx:         ctx,
		ContextID:   contextID,
		TestSuiteID: testSuiteID,
		Filter:      filter,
	}
	mock.lockListTests.Lock()
	mock.calls.ListTests = append(mock.calls.ListTests, callInfo)
	mock.lockListTests.Unlock()
	return mock.ListTestsFunc(ctx, contextID, testSuiteID, filter)
}

// ListTestsCalls gets all the calls that were made to ListTests.
// Check the length with:
//
//	len(mockedRepository.ListTestsCalls())
func (mock *RepositoryMock) ListTestsCalls() []struct {
	Ctx         context.Context
	ContextID   string
	TestSuiteID uuid.V7
	Filter      test.PageFilter[uuid.V7]
} {
	var calls []struct {
		Ctx         context.Context
		ContextID   string
		TestSuiteID uuid.V7
		Filter      test.PageFilter[uuid.V7]
	}
	mock.lockListTests.RLock()
	calls = mock.calls.ListTests
	mock.lockListTests.RUnlock()
	return calls
}

// ResetTestExecution calls ResetTestExecutionFunc.
func (mock *RepositoryMock) ResetTestExecution(ctx context.Context, testExecID test.TestExecutionID, resetTime time.Time) (*test.TestExecution, error) {
	if mock.ResetTestExecutionFunc == nil {
		panic("RepositoryMock.ResetTestExecutionFunc: method is nil but Repository.ResetTestExecution was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		TestExecID test.TestExecutionID
		ResetTime  time.Time
	}{
		Ctx:        ctx,
		TestExecID: testExecID,
		ResetTime:  resetTime,
	}
	mock.lockResetTestExecution.Lock()
	mock.calls.ResetTestExecution = append(mock.calls.ResetTestExecution, callInfo)
	mock.lockResetTestExecution.Unlock()
	return mock.ResetTestExecutionFunc(ctx, testExecID, resetTime)
}

// ResetTestExecutionCalls gets all the calls that were made to ResetTestExecution.
// Check the length with:
//
//	len(mockedRepository.ResetTestExecutionCalls())
func (mock *RepositoryMock) ResetTestExecutionCalls() []struct {
	Ctx        context.Context
	TestExecID test.TestExecutionID
	ResetTime  time.Time
} {
	var calls []struct {
		Ctx        context.Context
		TestExecID test.TestExecutionID
		ResetTime  time.Time
	}
	mock.lockResetTestExecution.RLock()
	calls = mock.calls.ResetTestExecution
	mock.lockResetTestExecution.RUnlock()
	return calls
}

// UpdateCaseExecutionFinished calls UpdateCaseExecutionFinishedFunc.
func (mock *RepositoryMock) UpdateCaseExecutionFinished(ctx context.Context, finished *test.FinishedCaseExecution) (*test.CaseExecution, error) {
	if mock.UpdateCaseExecutionFinishedFunc == nil {
		panic("RepositoryMock.UpdateCaseExecutionFinishedFunc: method is nil but Repository.UpdateCaseExecutionFinished was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Finished *test.FinishedCaseExecution
	}{
		Ctx:      ctx,
		Finished: finished,
	}
	mock.lockUpdateCaseExecutionFinished.Lock()
	mock.calls.UpdateCaseExecutionFinished = append(mock.calls.UpdateCaseExecutionFinished, callInfo)
	mock.lockUpdateCaseExecutionFinished.Unlock()
	return mock.UpdateCaseExecutionFinishedFunc(ctx, finished)
}

// UpdateCaseExecutionFinishedCalls gets all the calls that were made to UpdateCaseExecutionFinished.
// Check the length with:
//
//	len(mockedRepository.UpdateCaseExecutionFinishedCalls())
func (mock *RepositoryMock) UpdateCaseExecutionFinishedCalls() []struct {
	Ctx      context.Context
	Finished *test.FinishedCaseExecution
} {
	var calls []struct {
		Ctx      context.Context
		Finished *test.FinishedCaseExecution
	}
	mock.lockUpdateCaseExecutionFinished.RLock()
	calls = mock.calls.UpdateCaseExecutionFinished
	mock.lockUpdateCaseExecutionFinished.RUnlock()
	return calls
}

// UpdateCaseExecutionStarted calls UpdateCaseExecutionStartedFunc.
func (mock *RepositoryMock) UpdateCaseExecutionStarted(ctx context.Context, started *test.StartedCaseExecution) (*test.CaseExecution, error) {
	if mock.UpdateCaseExecutionStartedFunc == nil {
		panic("RepositoryMock.UpdateCaseExecutionStartedFunc: method is nil but Repository.UpdateCaseExecutionStarted was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Started *test.StartedCaseExecution
	}{
		Ctx:     ctx,
		Started: started,
	}
	mock.lockUpdateCaseExecutionStarted.Lock()
	mock.calls.UpdateCaseExecutionStarted = append(mock.calls.UpdateCaseExecutionStarted, callInfo)
	mock.lockUpdateCaseExecutionStarted.Unlock()
	return mock.UpdateCaseExecutionStartedFunc(ctx, started)
}

// UpdateCaseExecutionStartedCalls gets all the calls that were made to UpdateCaseExecutionStarted.
// Check the length with:
//
//	len(mockedRepository.UpdateCaseExecutionStartedCalls())
func (mock *RepositoryMock) UpdateCaseExecutionStartedCalls() []struct {
	Ctx     context.Context
	Started *test.StartedCaseExecution
} {
	var calls []struct {
		Ctx     context.Context
		Started *test.StartedCaseExecution
	}
	mock.lockUpdateCaseExecutionStarted.RLock()
	calls = mock.calls.UpdateCaseExecutionStarted
	mock.lockUpdateCaseExecutionStarted.RUnlock()
	return calls
}

// UpdateTestExecutionFinished calls UpdateTestExecutionFinishedFunc.
func (mock *RepositoryMock) UpdateTestExecutionFinished(ctx context.Context, finished *test.FinishedTestExecution) (*test.TestExecution, error) {
	if mock.UpdateTestExecutionFinishedFunc == nil {
		panic("RepositoryMock.UpdateTestExecutionFinishedFunc: method is nil but Repository.UpdateTestExecutionFinished was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Finished *test.FinishedTestExecution
	}{
		Ctx:      ctx,
		Finished: finished,
	}
	mock.lockUpdateTestExecutionFinished.Lock()
	mock.calls.UpdateTestExecutionFinished = append(mock.calls.UpdateTestExecutionFinished, callInfo)
	mock.lockUpdateTestExecutionFinished.Unlock()
	return mock.UpdateTestExecutionFinishedFunc(ctx, finished)
}

// UpdateTestExecutionFinishedCalls gets all the calls that were made to UpdateTestExecutionFinished.
// Check the length with:
//
//	len(mockedRepository.UpdateTestExecutionFinishedCalls())
func (mock *RepositoryMock) UpdateTestExecutionFinishedCalls() []struct {
	Ctx      context.Context
	Finished *test.FinishedTestExecution
} {
	var calls []struct {
		Ctx      context.Context
		Finished *test.FinishedTestExecution
	}
	mock.lockUpdateTestExecutionFinished.RLock()
	calls = mock.calls.UpdateTestExecutionFinished
	mock.lockUpdateTestExecutionFinished.RUnlock()
	return calls
}

// UpdateTestExecutionStarted calls UpdateTestExecutionStartedFunc.
func (mock *RepositoryMock) UpdateTestExecutionStarted(ctx context.Context, started *test.StartedTestExecution) (*test.TestExecution, error) {
	if mock.UpdateTestExecutionStartedFunc == nil {
		panic("RepositoryMock.UpdateTestExecutionStartedFunc: method is nil but Repository.UpdateTestExecutionStarted was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Started *test.StartedTestExecution
	}{
		Ctx:     ctx,
		Started: started,
	}
	mock.lockUpdateTestExecutionStarted.Lock()
	mock.calls.UpdateTestExecutionStarted = append(mock.calls.UpdateTestExecutionStarted, callInfo)
	mock.lockUpdateTestExecutionStarted.Unlock()
	return mock.UpdateTestExecutionStartedFunc(ctx, started)
}

// UpdateTestExecutionStartedCalls gets all the calls that were made to UpdateTestExecutionStarted.
// Check the length with:
//
//	len(mockedRepository.UpdateTestExecutionStartedCalls())
func (mock *RepositoryMock) UpdateTestExecutionStartedCalls() []struct {
	Ctx     context.Context
	Started *test.StartedTestExecution
} {
	var calls []struct {
		Ctx     context.Context
		Started *test.StartedTestExecution
	}
	mock.lockUpdateTestExecutionStarted.RLock()
	calls = mock.calls.UpdateTestExecutionStarted
	mock.lockUpdateTestExecutionStarted.RUnlock()
	return calls
}

// WithTx calls WithTxFunc.
func (mock *RepositoryMock) WithTx(ctx context.Context) (test.Repository, test.Tx, error) {
	if mock.WithTxFunc == nil {
		panic("RepositoryMock.WithTxFunc: method is nil but Repository.WithTx was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockWithTx.Lock()
	mock.calls.WithTx = append(mock.calls.WithTx, callInfo)
	mock.lockWithTx.Unlock()
	return mock.WithTxFunc(ctx)
}

// WithTxCalls gets all the calls that were made to WithTx.
// Check the length with:
//
//	len(mockedRepository.WithTxCalls())
func (mock *RepositoryMock) WithTxCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockWithTx.RLock()
	calls = mock.calls.WithTx
	mock.lockWithTx.RUnlock()
	return calls
}
