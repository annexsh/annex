package fake

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"go.temporal.io/api/enums/v1"
	"go.temporal.io/api/history/v1"
	"go.temporal.io/api/taskqueue/v1"
	"go.temporal.io/api/workflowservice/v1"
	"go.temporal.io/sdk/client"
	"google.golang.org/protobuf/types/known/timestamppb"
)

const WorkflowName = "FakeWorkflow"

type WorkflowerOption func(w *Workflower)

func WithHistory(history *history.History) WorkflowerOption {
	return func(w *Workflower) {
		w.history = history
	}
}

// Workflower is a fake implementation of a Temporal workflow client.
// The fake only supports workflows with a name equal to WorkflowName.
type Workflower struct {
	mu        *sync.RWMutex
	workflows map[string]*WorkflowRun // map keys generated by workflowsKey
	latest    map[string]string       // latest run id for a workflow
	history   *history.History
}

func NewWorkflower(opts ...WorkflowerOption) *Workflower {
	w := &Workflower{
		mu:        new(sync.RWMutex),
		workflows: map[string]*WorkflowRun{},
		latest:    map[string]string{},
	}
	for _, opt := range opts {
		opt(w)
	}
	return w
}

func (w *Workflower) ExecuteWorkflow(_ context.Context, options client.StartWorkflowOptions, wf any, _ ...any) (client.WorkflowRun, error) {
	if wf != WorkflowName {
		return nil, fmt.Errorf("executed workflow must be %s", WorkflowName)
	}

	// Options that are required for test workflows
	if options.WorkflowExecutionTimeout == 0 {
		return nil, errors.New("fake workflow execution timeout is required in start workflow options")
	} else if options.ID == "" {
		return nil, errors.New("fake workflow execution id is required in start workflow options")
	}

	wr := newWorkflowRun(options.ID, nil, nil)

	w.mu.Lock()
	w.workflows[workflowsKey(wr.GetID(), wr.GetRunID())] = wr
	w.latest[wr.GetID()] = wr.GetRunID()
	w.mu.Unlock()
	return wr, nil
}

func (w *Workflower) GetWorkflow(_ context.Context, workflowID string, runID string) client.WorkflowRun {
	wr, err := w.getWorkflowRun(workflowID, runID)
	if err != nil {
		return &WorkflowRun{err: err}
	}
	return wr
}

func (w *Workflower) GetWorkflowHistory(_ context.Context, _ string, _ string, _ bool, _ enums.HistoryEventFilterType) client.HistoryEventIterator {
	iter := &iterator{}

	if w.history == nil {
		iter.nextErr = errors.New("fake workflow history must be provided via the WithHistory option")
	} else {
		iter.events = make(chan *history.HistoryEvent, len(w.history.Events))
		for _, event := range w.history.Events {
			iter.events <- event
		}
	}

	close(iter.events)
	return iter
}

func (w *Workflower) ResetWorkflowExecution(_ context.Context, req *workflowservice.ResetWorkflowExecutionRequest) (*workflowservice.ResetWorkflowExecutionResponse, error) {
	// No real point in trying to simulate a reset workflow execution here.
	// Validate request params should suffice.
	if req.Reason == "" {
		return nil, errors.New("reason cannot be empty")
	}
	if req.WorkflowTaskFinishEventId == 0 {
		return nil, errors.New("workflow task finished event id must be a positive number")
	}
	if w.history == nil {
		return nil, errors.New("a valid workflow history must be configured in order to reset a workflow execution")
	}
	for _, event := range w.history.Events {
		if event.EventId == req.WorkflowTaskFinishEventId && isResettableEvent(event.EventType) {
			return &workflowservice.ResetWorkflowExecutionResponse{
				RunId: uuid.New().String(),
			}, nil
		}
	}
	return nil, errors.New(
		"workflow task finished event id does not correspond to a valid resettable event in the configured workflow history",
	)
}

func (w *Workflower) CancelWorkflow(_ context.Context, workflowID string, runID string) error {
	if _, err := w.getWorkflowRun(workflowID, runID); err != nil {
		return err
	}
	w.mu.RLock()
	defer w.mu.RUnlock()
	delete(w.workflows, workflowsKey(workflowID, runID))
	return nil
}

func (w *Workflower) DescribeTaskQueue(_ context.Context, _ string, _ enums.TaskQueueType) (*workflowservice.DescribeTaskQueueResponse, error) {
	return &workflowservice.DescribeTaskQueueResponse{
		Pollers: []*taskqueue.PollerInfo{
			{
				LastAccessTime: timestamppb.New(time.Now().UTC()),
				Identity:       uuid.NewString(),
				RatePerSecond:  30,
			},
		},
	}, nil
}

func (w *Workflower) getWorkflowRun(workflowID string, runID string) (client.WorkflowRun, error) {
	w.mu.RLock()
	defer w.mu.RUnlock()
	if runID == "" {
		var ok bool
		runID, ok = w.latest[workflowID]
		if !ok {
			return nil, fmt.Errorf("fake workflow not found for workflow id '%s'", workflowID)
		}
	}

	wr, ok := w.workflows[workflowsKey(workflowID, runID)]
	if !ok {
		return nil, fmt.Errorf("fake workflow not found for workflow id '%s' and run id '%s'", workflowID, runID)
	}
	return wr, nil
}

func workflowsKey(id string, runID string) string {
	return id + "." + runID
}

func isResettableEvent(eventType enums.EventType) bool {
	switch eventType {
	case enums.EVENT_TYPE_WORKFLOW_TASK_COMPLETED,
		enums.EVENT_TYPE_WORKFLOW_TASK_TIMED_OUT,
		enums.EVENT_TYPE_WORKFLOW_TASK_FAILED,
		enums.EVENT_TYPE_WORKFLOW_TASK_STARTED:
		return true

	}
	return false
}
